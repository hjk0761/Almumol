# Info
[컵라면](https://boj.kr/1781)

- 난이도: 골드 2
- 분류: 자료 구조, 그리디 알고리즘, 정렬, 우선순위 큐

## 💡 풀이 방법 요약

그리디와 우선순위 큐를 사용하여 풀었습니다.

먼저 문제를 데드라인 오름차순, 컵라면 내림차순으로 정렬한 이후에 그리디하게 현재까지 푼 문제 수(=시간) 보다 데드라인이 길면 컵라면을 얻었습니다.

여기서 얻은 컵라면을 최소힙으로 저장하였습니다.

그러다 데드라인이 같아지게 되면 그때부터 지금 풀 수 있는 가장 그리디한 문제랑 지금까지 푼 문제 중 가장 적은 컵라면을 얻은 문제를 비교합니다.

만약 이번에 풀 수 있는 문제가 이전에 푼 문제중 가장 적은 컵라면을 얻은 문제보다 컵라면을 많이 준다면 그 차이만큼 결과를 더하고 최소힙을 갱신하면 됩니다.

이를 위해 최소힙을 사용해서 문제별 얻은 컵라면을 관리했습니다.

위 풀이 방식이 의미하는건 만약 문제를 대체하게 된다면 이전에 푼 문제(가장 적은 컵라면을 줬던 문제)를 풀지 않고, 그 다음으로 푼 문제들을 한 차례씩 당겨서 푼 이후 마지막으로 새로운 문제를 푼다는 의미입니다.

지금까지 푼 문제들은 현재 시간 이전 어느 시점에서도 풀 수 있는 문제들이기 때문에 푸는 시점이 하나 당겨져도 문제를 풀 수 있다는 사실을 바꾸지 않기 때문에 가능한 풀이입니다.

## 👀 실패 이유

처음엔 그냥 현재 시간 이하의 문제 중 가장 컵라면이 많은 문제를 풀면 되는 줄 알았습니다.

이 경우 다음 예제처럼 그리디하게 먹으면 최대값을 찾지 못하는 문제를 확인하지 못합니다.

```
3
1 25
2 50
2 100
```

그래서 다음으론 지금 시간보다 데드라인이 긴 모든 문제 중 컵라면이 가장 많은 문제를 풀게 했습니다.

그러니 다음처럼 데드라인이 뒤인 문제가 더 크지만, 다 먹을 수 있는 문제를 확인하지 못합니다.

```
3
1 1
3 4
3 9
```

## 🙂 마무리
