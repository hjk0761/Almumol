# Info
[발코딩](https://boj.kr/3257)

- 난이도: 골드 3
- 분류: 다이나믹 프로그래밍

## 💡 풀이 방법 요약

간단한 dp 문제인데 저는 dfs 로 푼 것 같습니다 ㅋㅋ

LCS? 와 비슷하게 생각해봤습니다.

풀이에 앞서 조건들을 살펴보면 첫 번째 입력과 두 번쩨 입력의 길이의 합이 세 번째 입력의 글자수가 되고 각 입력에 사용된 알파벳은 모두 각각 사용된 갯수만큼 세 번째 입력에 포함되어 있습니다.

그래서 세 번째 입력을 한 자리씩 확인하면서 그 문자가 첫 번째 문자열에 지금 인덱스의 값과 같은지, 두 번째 문자열의 지금 인덱스의 값과 같은지를 확인했습니다.

이를 2차원 dp로 두면 각 축은 각 입력의 인덱스가 되고 dp에 지나온 경로를 저장해 주었습니다.

아마 조건이 조금만 더 컸어도 queue 나 dp 에서 메모리 초과가 발생했을 것 같습니다.

문제가 의도하는 적절한 풀이는 아닌 것 같다는 느낌이 듭니다.

그래도 이를 방지하기 위해 dp에서 이미 방문한 좌표일때 무조건 continue를 해주었는데, 이는 어느 경로를 따라왔든 해당 dp 좌표에선 첫 번째 문자열과 두 번째 문자열에서 사용한 글자수가 각각 같고, 문제의 정답은 정답 중 아무거나 출력하는 것이기 때문에 경로와 상관없이 한 번이라도 지나갔으면 패스해도 괜찮습니다.

## 👀 실패 이유

## 🙂 마무리

오랜만이라 쉬운 문제부터 풀었습니다.
