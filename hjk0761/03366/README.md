# Info
[수열 줄이기](https://boj.kr/3366)

- 난이도: 골드 1
- 분류: 자료 구조, 그리디 알고리즘

## 💡 풀이 방법 요약

그리디 문제입니다.

인접한 두 수에 reduce 연산을 취할 때에 큰 수만 남고 비용도 큰 수만큼 증가합니다.

이를 통해 연산의 결과가 작을 수록 유리함을 알 수 있고 연산의 결과가 유리하려면 최대한 작은 수끼리에 reduce 연산을 취해야 합니다.

하지만 두 수에 reduce 연산을 취해도 큰 수가 그대로 남아 원래 수열의 순서대로 앞 뒤의 숫자들과 비교해서 다시 reduce 연산을 취해야 합니다.

따라서 힙 자료구조를 사용할 순 없겠다고 생각했습니다.

1324 와 같은 수열에서 최소값은 10이 되는데, 이 때의 연산 수행 순서를 보면 1-3 혹은 3-2에 reduce 연산을 수행하고(순서는 상관없습니다), 이후 남은 3과 4에 reduce 연산을 취하게 됩니다.

이 경우와 4321, 1234의 경우를 대조해보면, 앞에서부터 순차적으로 확인하면서 지금 입력보다 큰 값이 나올 때 reduce 연산을 취하는 것이 최선이 됩니다.

이전까지의 최소값과 이보다 큰 다음 입력에 대해 reduce 연산을 취하면 최소값은 사라지고 다음 입력이 남고 비용이 그 만큼 증가합니다.

순서대로 볼 수 있는 이유는 1324에서 13과 32중 어느 곳을 먼저 reduce 연산을 취해도 3이 최대값이기 때문에 비용이 바뀌지 않기 때문입니다.

따라서 스택을 사용해서 수열을 앞에서부터 하나씩 스택에 추가하되, 내림차순이 아닌 값이 추가될 때 지금 수열의 top을 pop해주고, stack의 top 과 입력값을 비교해 그 중 작은 값을 비용으로 추가합니다(가장 작은 값이 이전 값과 새로 들어올 값 중 작은 값과 reduce 연산을 해줌).

만약 이렇게 연산을 취하고 stack의 길이가 1이라면 그 비용을 반환하면 되고, 2이상이라면 아직 reduce 연산을 취해줄 수 있고 stack이 내림차순으로 되어있으므로 뒤에서부터 하나가 남을때까지 reduce 연산을 취하는 것이 가장 적은 비용이 들어가는 방법입니다.

## 👀 실패 이유

내림차순으로 계산하면서 reduce 연산이 n-1회 시행되어서 이미 1개만 남았을 때와 아닐 때를 구분하지 못했습니다.

## 🙂 마무리

풀이를 알기 위해서 123, 1234 등 여러 수열들에서 순서를 바꿔가며 답이 어떻게 나오는지를 관찰했습니다.

작은 케이스에서 규칙성을 찾는게 중요한 것 같습니다.
