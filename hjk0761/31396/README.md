# Info
[과부하 방지](https://boj.kr/31396)

- 난이도: 플래 5
- 분류: 그리디 알고리즘, 정렬, 이분 탐색, 매개 변수 탐색

## 💡 풀이 방법 요약

그리디 알고리즘 입니다.

또한 제한이 너무 커 이분 탐색을 통해 시간 복잡도를 줄여야 합니다.

매개 변수 탐색을 통해 시간 복잡도를 줄이고, 그 매개 변수 탐색의 로직이 그리디입니다.

문제를 이해해보면 d_i 이하의 멀티탭 갯수라면 어디에든 그 전자기기를 연결할 수 있음을 알 수 있습니다.

우리가 알고 싶은건 몇 개의 전자기기를 연결할 수 있는지 이므로 최선의 경우를 생각해 d_i 가 큰 순으로 몇 개의 전자기기를 연결할 수 있는지를 보면 됩니다(그리디).

또한 멀티탭도 가능하면 연결하는 것이 손해가 아님을 알 수 있는데, 멀티탭은 기존 소켓 하나를 차지하면서 멀티탭의 최소 소켓수가 1이므로 멀티탭을 연결한 경우에 항상 이전의 소켓수보다 같거나 커짐을 알 수 있습니다.

따라서 멀티탭 또한 연결할 수 있는 순간에 가장 큰 소켓 수를 가지는 멀티탭을 연결하면 됩니다(그리디).

이는 앞서 d_i 이하의 어디든 전자기기를 연결할 수 있다는 점 때문입니다.

구체적으로 확인하는 로직은 다음과 같습니다.

앞서 말한것 처럼 d_i 가 큰 순으로 k개의 전자기기를 확인한다고 가정하겠습니다.

depth(지나온 멀티탭의 갯수) 에 따라 지금 depth 의 소켓에 d_i = depth 인 전자기기를 연결할 수 있는지를 먼저 확인합니다.

이 때 남은 소켓에 연결이 불가능하다면(d_i=depth 인 전자기기가 더 많다면) k개의 전자기기 연결이 불가능합니다.

가능하다면 그 만큼 소켓수를 채워주고, 남은 공간에 멀티탭을 소켓수가 큰 순으로 연결해줍니다.

이 때 멀티탭을 전부 사용했다면 멀티탭 연결로 증가된 공간에 남은 전자기기를 모두 연결할 수 있는지를 봅니다.

불가능하면 또한 k개의 전자기기를 연결할 수 없는 경우입니다.

멀티탭을 전부 사용한 것이 아니라면 depth 를 1 늘린 상황으로 계속 진행합니다.

## 👀 실패 이유

d_i 가 m보다 큰 경우를 놓쳐 인덱스 에러가 발생했습니다.

## 🙂 마무리

그리디임은 알았는데 처음엔 d_i가 작은 순으로 확인하려고 했습니다.

그러다보니 최적의 경우를 그리디하게 찾지 못했습니다.

여기서 잠깐 힌트를 얻으러 돌아다녀보니 어짜피 k개가 가능한지를 확인하는 과정이니 d_i 가 큰 순으로 확인해도 괜찮다는 것을 알 수 있었습니다.
