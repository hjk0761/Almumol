# Info
[내 이름 나무](https://boj.kr/33711)

- 난이도: 골드 1
- 분류: 자료 구조, 그래프 이론, 그래프 탐색, 너비 우선 탐색, 해시를 사용한 집합과 맵

## 💡 풀이 방법 요약

그래프 탐색 문제입니다.

구체적으로 너비 우선 탐색으로 풀 수 있습니다.

문제에서 알고 싶은건 결국 '같은 이름의 노드끼리의 최단 거리가 k보다 큰지 아닌지'입니다.

같은 이름의 노드가 없다면 당연히 탐색이 필요없이 불가능합니다.

만약 이름이 중복된다면, 그들 사이에서 최단 거리를 알아야 합니다.

이는 같은 이름의 모든 노드에서부터 bfs를 동시에 수행해서 알 수 있습니다.

여러 시작점으로부터 출발한 bfs 는 다른 시작점에 의해서 방문 처리된 노드를 방문하는 순간 최단 거리를 찾게 됩니다.

a, b, c가 같은 이름을 가지는 노드라고 할 때, a, b, c에서 동시에 bfs를 수행합니다(큐에 a, b, c를 모두 넣고 bfs를 수행한다는 뜻입니다).

a와 b가 가장 가까운 쌍이라고 할 때 a로부터 n만큼 떨어진곳을 방문처리한 후 b에서부터 m만큼 떨어진곳이 이 지점을 방문하는 경우,

n + m이 a와 b사이의 거리가 되고 이는 a, b, c 중 가능한 모든 쌍 중 가장 가까운 거리가 됩니다.

이를 이용하여 중복된 이름 사이의 최단 거리를 찾고, 이 거리가 k 이하인 경우 개명이 가능합니다.

추가로 bfs 수행 중 이미 한 시작점으로부터 거리가 k 이상인 경우는 최단 거리가 k를 넘을 수 밖에 없으므로 조기종료했습니다.

## 👀 실패 이유

처음엔 모든 노드에서 bfs를 돌려 k번 안에 같은 이름의 노드를 방문하는지를 확인했습니다.

이는 최악의 경우 O(N^2)가 나와 시간초과였습니다.

다음으로 앞선 경우에서 몇 가지 전처리를 더했습니다.

먼저 중복된 이름의 노드가 없는 경우(이름이 유니크한 경우)는 bfs를 수행할 필요가 없고, 또한 모든 이름이 유일하다면 아예 탐색을 안해도 됩니다.

물론 시간복잡도는 그대로이므로 시간초과입니다.

이후 로직을 풀이 방법대로 바꿔 맞췄습니다.

같은 코드를 python3으로 제출해도 시간초과입니다.

## 🙂 마무리
