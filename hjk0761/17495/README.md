# Info
[피아노 연주](https://boj.kr/17495)

- 난이도: 골드 1
- 분류: 다이나믹 프로그래밍, 문자열

## 💡 풀이 방법 요약

DP 문제 입니다.

처음엔 그리디하게 지금 왼손과 오른손 중 다음 건반과 가까운 손을 움직이면 그게 최소일 것이라고 생각했는데, 다음과 같은 반례를 발견했습니다.

```
E0 A0
2
F0# C0
```

위 경우는 그리디한 접근으로는 둘 다 왼손이 움직여서 2 + 6 = 8의 이동을 가지는데, 최적의 해는 오른손, 왼손 순으로 움직여 3 + 4 = 7의 이동이 나옵니다.

위 예시를 발견하고나서 다른 방법을 생각했는데, 모든 경우의 수를 따지자니 왼손 오른손 2가지 경우를 최대 1000번 확인해야 하므로 2^1000 가지의 경우의 수를 확인하는 건 당연하게도 시간초과가 발생할 것입니다.

우리가 알아야 할 것은 (어느 손으로 움직였든) 마지막 음까지 연주했을 때에 두 손의 최소 이동 거리입니다.

이를 알기 위해선 악표의 각 음을 누를 때 어느 손으로 움직였을 때에 얼마만큼의 이동 거리가 나오는지를 알아야합니다.

즉 악보의 i번째 음을 연주할 때 왼손과 오른손의 위치에 따라 이동의 최소값을 알아야하고, 한 음을 연주할 때 한 손을 움직였다면 한 손은 움직이지 않는다는 점을 이용해야 합니다.

DP를 3차원으로 구성하고, 인덱스는 각각 i번째 음을 누를 때(1 <= i <= n), j음계를 왼손으로 누를 때, k음계를 오른손으로 누를때를 의미하도록 설정합니다.

최소값을 저장해야 하므로 DP의 초기값은 가능한 큰 수(C0 부터 B9#까지 120개의 음계를 최대 1000번 움직이므로 120000 이상)로 설정해둬야 합니다.

처음 왼손과 오른손의 위치를 l, r이라고 할 때 dp[0][i][j] = 0으로 둡니다.

이후 1번째 음부터 n번째 음까지 아래를 반복하고 dp[n] 중 최소값을 찾으면 됩니다.

dp[i-1] 중에 최대값이 아닌 칸에 대해서, 그 칸을 dp[i-1][j][k] 라고 할 때 왼손을 이동하는 경우(dp[i][새로운음계위치][k]), 오른손을 이동하는 경우(dp[i][j][새로운음계위치])를 모두 계산해줍니다.

이렇게 계산하면 최소로 손을 움직이는 횟수를 알 수 있지만, 이를 위한 경로는 알 수 없습니다.

따라서 dp값이 갱신될 때마다 그 좌표를 같이 저장하는 방식으로 구현해 나중에 역으로 돌아가며 눌러야 할 손을 알 수 있습니다.

## 👀 실패 이유

같은 풀이로 python3은 메모리초과가 발생하고, pypy3는 발생하지 않네요.

최적화의 문제인지 잘 모르겠지만, 다른 사람의 풀이를 보니 dp 대신 방문 처리를 잘 해서 재귀를 사용해도 메모리 초과가 발생하진 않는 것 같습니다.

처음엔 dp 테이블도 36((value, (prev_x, prev_y)) 튜플 자료형의 메모리 값) * 121 * 121 * 1000 = 52707600 약 52MB로 메모리초과가 발생하지 않겠다고 생각했는데, 다른곳에서 누수가 있었나봅니다.

## 🙂 마무리

아이디어는 외부에서 참고했습니다. 확실히 DP 문제는 아이디어 싸움이라는 생각이 다시 들었습니다.

다차원 DP 로 사고를 넓힐 수 있는 연습이 확실히 필요한 것 같습니다.
